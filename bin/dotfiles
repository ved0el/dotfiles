#!/usr/bin/env bash

# =============================================================================
# Dotfiles Manager - Clean, Cross-Platform Installation Script
# =============================================================================
# Features: Interactive/Non-interactive, Profile-based, Cross-platform
# Supports: macOS (Darwin), Linux (Ubuntu, Fedora, Arch, etc.)
# Author: Veteran Programmer - Clean, Maintainable, Production-Ready Code
# =============================================================================

# Enable strict error handling
set -euo pipefail

# =============================================================================
# Configuration & Constants
# =============================================================================
readonly DEFAULT_ROOT="$HOME/.dotfiles"
readonly DEFAULT_PROFILE="minimal"
readonly DEFAULT_VERBOSE="false"

# URLs - Easy to update
readonly REPO_URL="https://github.com/ved0el/dotfiles.git"
readonly INSTALL_COMMAND_URL="https://tinyurl.com/get-dotfiles"
readonly DOCS_URL="https://github.com/ved0el/dotfiles"

# Configuration file location
readonly CONFIG_FILE="$HOME/.zshenv"

# =============================================================================
# Cross-Platform Detection & Utilities
# =============================================================================
get_os_type() { uname -s; }

# Cross-platform sed in-place editing
sed_inplace() {
    local file="$1"; shift
    [[ "$(get_os_type)" == "Darwin" ]] && sed -i '' "$@" "$file" || sed -i "$@" "$file"
}

# Extract value from config line (format: export VAR="value")
extract_config_value() {
    local var_name="$1"
    local config_file="$2"

    # Simple extraction using bash parameter expansion
    local line
    line=$(grep "^export ${var_name}=" "$config_file" 2>/dev/null || echo "")
    [[ -z "$line" ]] && return 1

    # Extract value between quotes
    local value="${line#*\"}"  # Remove everything before first quote
    value="${value%\"*}"      # Remove everything after last quote

    [[ -n "$value" ]] && echo "$value"
}

# =============================================================================
# Color & UI Constants
# =============================================================================
# Modern ANSI color codes - compatible with Windows Terminal, macOS Terminal, Linux
# Using standard 16-color palette for maximum compatibility
readonly RED='\033[31m'
readonly GREEN='\033[32m'
readonly YELLOW='\033[33m'
readonly BLUE='\033[34m'
readonly MAGENTA='\033[35m'
readonly CYAN='\033[36m'
readonly WHITE='\033[37m'
readonly GRAY='\033[90m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'            # Reset all attributes

# UI symbols - fallback to ASCII if Unicode not supported
readonly CHECK="âœ“"
readonly CROSS="âœ—"
readonly ARROW="â†’"
readonly BULLET="â€¢"

# =============================================================================
# Logging Functions
# =============================================================================
# Check if verbose mode is enabled
is_verbose() {
    [[ "${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}" == "true" ]]
}

# Run a command with verbose output enabled (for menu operations)
with_menu_output() {
    local original_verbose="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"
    export DOTFILES_VERBOSE="true"
    "$@"
    local result=$?
    export DOTFILES_VERBOSE="$original_verbose"
    return $result
}

log_info() { echo -e "${CYAN}${BULLET}${RESET} ${WHITE}$1${RESET}"; }
log_success() { echo -e "${GREEN}${CHECK}${RESET} ${BOLD}${GREEN}$1${RESET}"; }
log_warning() { echo -e "${YELLOW}âš ${RESET}  ${YELLOW}$1${RESET}"; }
log_error() { echo -e "${RED}${CROSS}${RESET} ${BOLD}${RED}$1${RESET}"; }
log_step() { echo -e "${MAGENTA}${ARROW}${RESET} ${BOLD}${MAGENTA}$1${RESET}"; }
log_dim() { echo -e "${GRAY}  $1${RESET}"; }
log_verbose() { is_verbose && echo -e "${MAGENTA}[VERBOSE]${RESET} ${GRAY}$1${RESET}"; }

# =============================================================================
# Validation Functions
# =============================================================================
# Validate profile value (returns 0 if valid, 1 if invalid)
validate_profile() {
    local profile="$1"
    local valid_profiles=("minimal" "server" "develop")

    for valid_profile in "${valid_profiles[@]}"; do
        [[ "$profile" == "$valid_profile" ]] && return 0
    done

    log_error "Invalid profile '$profile'. Valid profiles: ${valid_profiles[*]}"
    return 1
}

is_interactive() { [[ -t 0 && -t 1 ]]; }

die() { log_error "$1"; exit 1; }

# =============================================================================
# Banner & UI Functions
# =============================================================================
show_banner() {
    echo -e "${BOLD}${BLUE}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
    echo -e "${BOLD}${BLUE}â”‚${RESET}                    ${BOLD}${WHITE}ðŸš€ Dotfiles Manager${RESET}                         ${BOLD}${BLUE}â”‚${RESET}"
    echo -e "${BOLD}${BLUE}â”‚${RESET}              ${GRAY}Clean, Cross-Platform Setup${RESET}                       ${BOLD}${BLUE}â”‚${RESET}"
    echo -e "${BOLD}${BLUE}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
    echo
}

# Show section header (only in verbose mode)
show_section() {
    is_verbose || return 0
    echo; echo -e "${BOLD}${MAGENTA}â—† $1${RESET}"
    echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

# Show subsection header (only in verbose mode)
show_subsection() {
    is_verbose || return 0
    echo -e "${CYAN}${BULLET}${RESET} ${BOLD}${CYAN}$1${RESET}";
}

# =============================================================================
# Configuration Management
# =============================================================================
# Set default values for all dotfiles variables
set_defaults() {
    export DOTFILES_ROOT="${DOTFILES_ROOT:-$DEFAULT_ROOT}"
    export DOTFILES_PROFILE="${DOTFILES_PROFILE:-$DEFAULT_PROFILE}"
    export DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"
}

load_config() {
    [[ ! -f "$CONFIG_FILE" ]] && {
        log_verbose "No configuration file found at $CONFIG_FILE"
        return 0
    }

    log_verbose "Loading configuration from $CONFIG_FILE"

    # Load configuration values with fallbacks
    local value

    if value=$(extract_config_value "DOTFILES_ROOT" "$CONFIG_FILE" 2>/dev/null || true); then
        [[ -n "$value" ]] && export DOTFILES_ROOT="$value"
        log_verbose "Loaded DOTFILES_ROOT: ${value:-default}"
    fi

    if value=$(extract_config_value "DOTFILES_PROFILE" "$CONFIG_FILE" 2>/dev/null || true); then
        [[ -n "$value" ]] && export DOTFILES_PROFILE="$value"
        log_verbose "Loaded DOTFILES_PROFILE: ${value:-default}"
    fi

    if value=$(extract_config_value "DOTFILES_VERBOSE" "$CONFIG_FILE" 2>/dev/null || true); then
        [[ -n "$value" ]] && export DOTFILES_VERBOSE="$value"
        log_verbose "Loaded DOTFILES_VERBOSE: ${value:-default}"
    fi

    log_verbose "Configuration loaded successfully"
}

save_config() {
    # Ensure config directory exists
    local config_dir
    config_dir=$(dirname "$CONFIG_FILE")
    [[ ! -d "$config_dir" ]] && mkdir -p "$config_dir"

    # Create backup if config file exists
    [[ -f "$CONFIG_FILE" ]] && cp "$CONFIG_FILE" "${CONFIG_FILE}.backup" 2>/dev/null

    # Remove existing dotfiles exports and comments
    if [[ -f "$CONFIG_FILE" ]]; then
        sed_inplace "$CONFIG_FILE" '/^export DOTFILES_/d'
        sed_inplace "$CONFIG_FILE" '/^# Dotfiles Configuration/d'
    fi

    # Add new configuration block with timestamp
    cat >> "$CONFIG_FILE" << EOF
# Dotfiles Configuration
export DOTFILES_ROOT="${DOTFILES_ROOT:-$DEFAULT_ROOT}"
export DOTFILES_PROFILE="${DOTFILES_PROFILE:-$DEFAULT_PROFILE}"
export DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"
EOF

    log_verbose "Configuration saved to $CONFIG_FILE"
}

# =============================================================================
# Environment Setup
# =============================================================================
setup_environment() {
    # Always show progress, detailed section only in verbose mode
    log_step "Setting up environment..."
    show_section "Configuration Setup"

    # Load existing configuration and set defaults
    load_config
    set_defaults

    # Auto-detect repository
    if [[ -z "${DOTFILES_REPO:-}" ]]; then
        if [[ -d "$SCRIPT_DIR/.git" ]]; then
            DOTFILES_REPO=$(cd "$SCRIPT_DIR" && git remote get-url origin 2>/dev/null || echo "")
            log_verbose "Auto-detected repository from local git"
        else
            DOTFILES_REPO="$REPO_URL"
            log_verbose "Using default repository"
        fi
    fi
    export DOTFILES_REPO

    # Validate settings (show error but don't exit)
    validate_profile "$DOTFILES_PROFILE" || {
        log_warning "Using default profile '$DEFAULT_PROFILE'"
        export DOTFILES_PROFILE="$DEFAULT_PROFILE"
    }
}

# =============================================================================
# Repository Management
# =============================================================================
is_fresh_install() {
    [[ ! -d "$DOTFILES_ROOT/.git" ]]
}

setup_repository() {
    # Always show progress, detailed section only in verbose mode
    show_section "Repository Management"

    if is_fresh_install; then
        # INSTALL: Clone the repository
        log_step "Installing dotfiles (fresh installation)..."
        is_verbose && log_step "Cloning repository"
        if [[ -z "$DOTFILES_REPO" ]]; then
            log_error "Repository URL not specified"
            return 1
        fi
        is_verbose && log_dim "Downloading from $DOTFILES_REPO..."
        git clone "$DOTFILES_REPO" "$DOTFILES_ROOT" >/dev/null 2>&1 || {
            log_error "Failed to clone repository"
            return 1
        }
        cd "$DOTFILES_ROOT"
        log_success "Repository cloned at $DOTFILES_ROOT"
    else
        # UPDATE: Hard reset with rebase enabled, then pull
        log_step "Updating dotfiles (pulling latest changes)..."
        cd "$DOTFILES_ROOT"
        is_verbose && log_step "Updating existing repository"

        # Get current branch
        local current_branch
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
        is_verbose && log_dim "Current branch: $current_branch"

        # Fetch latest changes
        is_verbose && log_dim "Fetching latest changes..."
        git fetch origin >/dev/null 2>&1

        # Hard reset to remote branch with rebase
        is_verbose && log_dim "Hard resetting to origin/$current_branch..."
        git reset --hard "origin/$current_branch" >/dev/null 2>&1 || {
            log_warning "Failed to reset, attempting normal pull..."
        }

        # Pull with rebase enabled
        is_verbose && log_dim "Pulling latest changes with rebase..."
        git pull --rebase origin "$current_branch" >/dev/null 2>&1 || {
            log_error "Failed to pull latest changes"
            return 1
        }

        log_success "Repository updated at $DOTFILES_ROOT"
    fi
}

# =============================================================================
# Symlink Management
# =============================================================================
readonly EXCLUDE_PATTERNS=(
    "README.md" ".gitignore" "install" "bin" "config" "zshrc.d"
    ".vscode" ".git" "*.zwc" "*.zwc.old"
)

should_exclude() {
    local item="$1"
    for pattern in "${EXCLUDE_PATTERNS[@]}"; do
        # Use glob matching for patterns with wildcards, exact match otherwise
        if [[ "$pattern" == *"*"* ]]; then
            [[ "$item" == $pattern ]] && return 0
        else
            [[ "$item" == "$pattern" ]] && return 0
        fi
    done
    return 1
}

# Create a symlink with proper error handling
create_single_symlink() {
    local source_path="$1"
    local target_path="$2"
    local display_name="$3"

    # Remove existing symlink or file
    if [[ -L "$target_path" || -e "$target_path" ]]; then
        rm -rf "$target_path" || {
            log_error "Failed to remove existing $target_path"
            return 1
        }
    fi

    # Create symlink (always do the work, only show output if verbose)
    if ln -sf "$source_path" "$target_path"; then
        is_verbose && log_dim "${GREEN}${CHECK}${RESET} $display_name ${MAGENTA}${ARROW}${RESET} $target_path"
        return 0
    else
        log_error "Failed to create symlink: $source_path -> $target_path"
        return 1
    fi
}

# Link files from source directory to target directory
link_directory_files() {
    local source_dir="$1"
    local target_prefix="$2"
    local subsection_title="$3"

    [[ ! -d "$source_dir" ]] && return 0

    show_subsection "$subsection_title"

    local linked_count=0
    local failed_count=0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue  # Skip if item doesn't exist

        local name=$(basename "$item")
        local target="$target_prefix$name"

        # Ensure target directory exists
        local target_dir
        target_dir=$(dirname "$target")
        [[ ! -d "$target_dir" ]] && mkdir -p "$target_dir"

        if ! should_exclude "$name" && [[ -f "$item" || -d "$item" ]]; then
            if create_single_symlink "$item" "$target" "$name"; then
                ((linked_count++))
            else
                ((failed_count++))
            fi
        fi
    done

    log_verbose "Linked $linked_count files from $source_dir"
    [[ $failed_count -gt 0 ]] && log_warning "Failed to link $failed_count files"
}

create_symlinks() {
    # Always show progress message, detailed section only in verbose mode
    log_step "Creating symlinks..."
    show_section "Creating symlinks..."

    # Link dotfiles (files in root directory)
    link_directory_files "$DOTFILES_ROOT" "$HOME/." "Linking dotfiles..."

    # Link config files
    mkdir -p "$HOME/.config"
    link_directory_files "$DOTFILES_ROOT/config" "$HOME/.config/" "Linking config files..."
}

# Check symlinks in a directory
check_directory_symlinks() {
    local source_dir="$1"
    local target_prefix="$2"
    local subsection_title="$3"
    local total_links_ref="$4"
    local broken_links_ref="$5"

    [[ ! -d "$source_dir" ]] && return 0

    show_subsection "$subsection_title"

    local item_count=0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue

        local name=$(basename "$item")
        local target="$target_prefix$name"

        if ! should_exclude "$name" && [[ -f "$item" || -d "$item" ]]; then
            ((item_count++))
            if [[ -L "$target" ]] && [[ -e "$target" ]]; then
                is_verbose && log_dim "${GREEN}${CHECK}${RESET} $name ${MAGENTA}${ARROW}${RESET} $target"
                eval "$total_links_ref=\$(($total_links_ref + 1))"
            else
                log_error "Broken or missing: $target"
                eval "$broken_links_ref=\$(($broken_links_ref + 1))"
            fi
        fi
    done

    log_verbose "Checked $item_count items in $source_dir"
}

verify_symlinks() {
    # Always show progress, detailed section only in verbose mode
    log_step "Verifying symlinks..."
    show_section "Verifying symlinks..."

    [[ -n "$DOTFILES_ROOT" ]] || { log_error "DOTFILES_ROOT is not set"; return 1; }
    [[ -d "$DOTFILES_ROOT" ]] || { log_error "Dotfiles directory not found: $DOTFILES_ROOT"; return 1; }

    local total_links=0
    local broken_links=0

    # Check dotfiles symlinks
    check_directory_symlinks "$DOTFILES_ROOT" "$HOME/." "Checking dotfiles symlinks..." total_links broken_links

    # Check config files symlinks
    check_directory_symlinks "$DOTFILES_ROOT/config" "$HOME/.config/" "Checking config files symlinks..." total_links broken_links

    # Summary (always show)
    echo
    if [[ $broken_links -eq 0 ]]; then
        log_success "All $total_links symlinks are working"
        return 0
    else
        log_warning "Found $broken_links broken symlinks out of $total_links total"
        return 1
    fi
}

# =============================================================================
# Package Installation
# =============================================================================
install_packages() {
    # Always show progress, detailed section only in verbose mode
    log_step "Installing packages for profile: $DOTFILES_PROFILE"
    show_section "Package Installation"

    # Check if zsh is available
    command -v zsh &>/dev/null || {
        log_warning "zsh not found, skipping package installation"
        return 0
    }

    # Determine which packages to install based on profile
    local pkg_patterns=('*_m_*.zsh')
    [[ "$DOTFILES_PROFILE" == "server" || "$DOTFILES_PROFILE" == "develop" ]] && pkg_patterns+=('*_s_*.zsh')
    [[ "$DOTFILES_PROFILE" == "develop" ]] && pkg_patterns+=('*_d_*.zsh')

    echo
    log_info "Checking packages for profile: $DOTFILES_PROFILE"
    echo

    # Source each matching package file to trigger installation
    (   # Subshell to contain shopt changes
        shopt -s nullglob  # Allow empty globs
        for pattern in "${pkg_patterns[@]}"; do
            for pkg_file in "$DOTFILES_ROOT/zshrc.d/pkg/$pattern"; do
                if [[ -f "$pkg_file" ]]; then
                    local pkg_name=$(basename "$pkg_file" .zsh | sed 's/^[0-9]*_[msd]_//')
                    is_verbose && log_dim "Checking package: $pkg_name ($(basename "$pkg_file"))"

                    # Source the package file (will check and install if needed)
                    if source "$pkg_file" 2>&1; then
                        true  # Success handled in package file
                    else
                        log_error "Failed to process package: $pkg_name"
                    fi
                fi
            done
        done
    )

    echo
    log_success "Package check and installation completed"

    # Show profile-specific package list
    echo
    log_info "Profile '$DOTFILES_PROFILE' includes:"
    case "$DOTFILES_PROFILE" in
        minimal)
            echo -e "  ${CYAN}${BULLET}${RESET} tmux, sheldon"
            ;;
        server)
            echo -e "  ${CYAN}${BULLET}${RESET} tmux, sheldon (minimal)"
            echo -e "  ${CYAN}${BULLET}${RESET} bat, fzf, eza, fd, ripgrep, tealdeer, zoxide"
            ;;
        develop)
            echo -e "  ${CYAN}${BULLET}${RESET} tmux, sheldon (minimal)"
            echo -e "  ${CYAN}${BULLET}${RESET} bat, fzf, eza, fd, ripgrep, tealdeer, zoxide (server)"
            echo -e "  ${CYAN}${BULLET}${RESET} nvm, pyenv, goenv, curlie"
            ;;
    esac
}

# =============================================================================
# Profile Management
# =============================================================================
configure_profile() {
    log_info "Configuring profile: $DOTFILES_PROFILE"
    save_config
    log_success "Profile configured successfully"
}

# =============================================================================
# Main Installation Flow
# =============================================================================
install_dotfiles() {
    show_banner

    local is_install=false
    is_fresh_install && is_install=true

    if $is_install; then
        log_step "Starting dotfiles installation (fresh install)"
    else
        log_step "Starting dotfiles update"
    fi

    # Step 1: Setup environment (load config, set defaults)
    setup_environment

    # Step 2: Clone or update the repository
    setup_repository || {
        log_error "Failed to setup repository"
        return 1
    }

    # Step 3: (Re)link the files (always relink to ensure latest structure)
    create_symlinks

    # Step 4: Install required packages (only on fresh install)
    if $is_install; then
        install_packages
    else
        is_verbose && log_info "Skipping package installation (update mode)"
    fi

    # Step 5: Save configuration
    configure_profile

    # Success message
    echo
    if $is_install; then
        echo -e "${BOLD}${GREEN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
        echo -e "${BOLD}${GREEN}â”‚${RESET}${BOLD}${WHITE}                    ðŸŽ‰ Installation Complete!                   ${RESET}${BOLD}${GREEN}â”‚${RESET}"
        echo -e "${BOLD}${GREEN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
        echo

        log_success "Profile '$DOTFILES_PROFILE' is now active"

        # Show what's included
        echo
        echo -e "${BOLD}${WHITE}What's Included:${RESET}"
        case "$DOTFILES_PROFILE" in
            minimal)
                echo -e "  ${GREEN}${CHECK}${RESET} Shell essentials (zsh, sheldon, tmux)"
                ;;
            server)
                echo -e "  ${GREEN}${CHECK}${RESET} Shell + utilities (bat, fzf, eza, fd, ripgrep, tealdeer, zoxide)"
                ;;
            develop)
                echo -e "  ${GREEN}${CHECK}${RESET} Full development environment"
                echo -e "  ${GREEN}${CHECK}${RESET} All server tools + dev tools (nvm, pyenv, goenv, curlie)"
                ;;
        esac
    else
        echo -e "${BOLD}${GREEN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
        echo -e "${BOLD}${GREEN}â”‚${RESET}${BOLD}${WHITE}                      âœ¨ Update Complete!                       ${RESET}${BOLD}${GREEN}â”‚${RESET}"
        echo -e "${BOLD}${GREEN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
        echo

        log_success "Dotfiles updated to latest version"
        log_success "Profile '$DOTFILES_PROFILE' is active"
    fi

    # Step 6: Source a new zsh shell (always)
    echo
    if command -v zsh &>/dev/null; then
        log_info "Starting new zsh shell..."
        exec zsh -l </dev/null
    else
        log_warning "zsh not found, please restart your terminal manually"
    fi
}

# =============================================================================
# Uninstallation
# =============================================================================
# Remove symlinks from a directory
remove_symlinks_from_dir() {
    local source_dir="$1"
    local target_prefix="$2"
    local unlink_count_ref="$3"

    [[ ! -d "$source_dir" ]] && return 0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue

        local name=$(basename "$item")
        local target="$target_prefix$name"

        if [[ -L "$target" ]] && [[ "$(readlink "$target")" == *"/.dotfiles/"* ]]; then
            rm "$target" && eval "$unlink_count_ref=\$(($unlink_count_ref + 1))"
        fi
    done
}

uninstall_dotfiles() {
    log_warning "This will remove all dotfiles symlinks and configuration"

    if is_interactive; then
        echo -n "Are you sure? [y/N]: "
        read -r response
        [[ ! "$response" =~ ^[Yy]$ ]] && { log_info "Uninstallation cancelled"; return 0; }
    fi

    local unlink_count=0

    # Remove root and config symlinks using shared function
    remove_symlinks_from_dir "$DOTFILES_ROOT" "$HOME/." unlink_count
    remove_symlinks_from_dir "$DOTFILES_ROOT/config" "$HOME/.config/" unlink_count

    # Remove from .zshenv
    [[ -f "$CONFIG_FILE" ]] && {
        sed_inplace "$CONFIG_FILE" '/^export DOTFILES_/d'
        sed_inplace "$CONFIG_FILE" '/^# Dotfiles Configuration/d'
    }

    # Remove dotfiles directory
    [[ -d "$DOTFILES_ROOT" ]] && rm -rf "$DOTFILES_ROOT"

    log_success "Removed $unlink_count symlinks and dotfiles directory"
}

# =============================================================================
# Interactive Menu
# =============================================================================
show_menu() {
    clear
    show_banner

    # Ensure variables are set with defaults
    set_defaults

    echo -e "${BOLD}${WHITE}Current Configuration:${RESET}"
    echo -e "  ${GRAY}OS:${RESET}                  ${MAGENTA}$(get_os_type)${RESET}"
    echo -e "  ${GRAY}Path:${RESET}                ${CYAN}${DOTFILES_ROOT}${RESET}"
    echo -e "  ${GRAY}Profile:${RESET}             ${YELLOW}${DOTFILES_PROFILE}${RESET}"
    echo -e "  ${GRAY}Verbose:${RESET}             ${GREEN}${DOTFILES_VERBOSE}${RESET}"

    echo
    echo -e "${BOLD}${WHITE}Available Actions:${RESET}"
    echo -e "  ${CYAN}1)${RESET} Install/Update dotfiles"
    echo -e "  ${CYAN}2)${RESET} Change profile (minimal/server/develop)"
    echo -e "  ${CYAN}3)${RESET} Create/refresh symlinks only"
    echo -e "  ${CYAN}4)${RESET} Install required packages"
    echo -e "  ${CYAN}5)${RESET} Verify symlinks"
    echo -e "  ${CYAN}6)${RESET} Uninstall everything"
    echo -e "  ${CYAN}7)${RESET} Toggle verbose mode"
    echo -e "  ${CYAN}8)${RESET} Show help"
    echo -e "  ${CYAN}q)${RESET} Quit"

    echo
    echo -n "Choose an option [1-8,q]: "
}

interactive_menu() {
    # Load existing configuration for interactive session
    load_config

    while true; do
        show_menu
        read -r choice

        case "$choice" in
            1)
                with_menu_output install_dotfiles
                ;;
            2)
                echo -n "Enter new profile (minimal/server/develop): "
                read -r new_profile
                if validate_profile "$new_profile" 2>/dev/null; then
                    export DOTFILES_PROFILE="$new_profile"
                    save_config
                    log_success "Profile changed to: $new_profile"
                fi
                sleep 2
                ;;
            3)
                with_menu_output create_symlinks
                with_menu_output verify_symlinks
                echo -e "\n${GRAY}Press Enter to continue...${RESET}"
                read -r
                ;;
            4)
                with_menu_output install_packages
                echo -e "\n${GRAY}Press Enter to continue...${RESET}"
                read -r
                ;;
            5)
                with_menu_output verify_symlinks
                echo -e "\n${GRAY}Press Enter to continue...${RESET}"
                read -r
                ;;
            6)
                with_menu_output uninstall_dotfiles
                [[ $? -eq 0 ]] && exit 0
                echo -e "\n${GRAY}Press Enter to continue...${RESET}"
                read -r
                ;;
            7)
                # Toggle verbose mode (for zshrc sourcing only)
                if is_verbose; then
                    export DOTFILES_VERBOSE="false"
                    log_success "Verbose mode disabled (affects shell startup only)"
                else
                    export DOTFILES_VERBOSE="true"
                    log_success "Verbose mode enabled (affects shell startup only)"
                fi
                save_config
                sleep 2
                ;;
            8)
                echo
                echo -e "${BOLD}${MAGENTA}Help - Dotfiles Manager${RESET}"
                echo
                echo -e "${BOLD}${WHITE}Installation:${RESET}"
                echo -e "  ${CYAN}${BULLET}${RESET} Interactive: bash <(curl -fsSL $INSTALL_COMMAND_URL)"
                echo -e "  ${CYAN}${BULLET}${RESET} One-liner:   curl -fsSL $INSTALL_COMMAND_URL | bash"
                echo
                echo -e "${BOLD}${WHITE}Profiles:${RESET}"
                echo -e "  ${YELLOW}minimal${RESET}  - Shell essentials (sheldon, tmux)"
                echo -e "  ${YELLOW}server${RESET}   - Shell + utilities (bat, fzf, eza, etc.)"
                echo -e "  ${YELLOW}develop${RESET}  - Full development environment"
                echo
                echo -e "${BOLD}${WHITE}Environment Variables:${RESET}"
                echo -e "  ${CYAN}DOTFILES_ROOT${RESET}     - Installation directory"
                echo -e "  ${CYAN}DOTFILES_PROFILE${RESET}  - Profile selection"
                echo -e "  ${CYAN}DOTFILES_VERBOSE${RESET}  - Verbose logging (affects shell startup only)"
                echo -e "  ${GRAY}Note: dotfiles menu always shows detailed output for debugging${RESET}"
                echo
                echo -e "${GRAY}Press Enter to continue...${RESET}"
                read -r
                ;;
            q)
                save_config
                log_success "Goodbye!"
                exit 0
                ;;
            *) log_error "Invalid choice"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# Command Line Interface
# =============================================================================
show_version() {
    echo "dotfiles - Cross-platform dotfiles manager"
    echo "https://github.com/ved0el/dotfiles"
}

show_usage() {
    show_version
    echo
    cat << EOF
USAGE:
  $SCRIPT_NAME [COMMAND] [OPTIONS]

COMMANDS:
  install     Install or update dotfiles (default)
              â€¢ Fresh install: clone repo, link files, install packages, start new shell
              â€¢ Update: hard reset + pull with rebase, relink files, start new shell
  uninstall   Remove all dotfiles and configuration
  link        Create or refresh symlinks only
  profile     Change profile (minimal/server/develop)
  packages    Install required packages for current profile
  verify      Verify all symlinks are working
  version     Show version information
  help        Show this help message

OPTIONS:
  -v, --verbose    Enable verbose output (affects shell startup only)
                   Note: dotfiles menu always shows detailed output
  -h, --help       Show this help message

EXAMPLES:
  $SCRIPT_NAME                    # Interactive installation
  $SCRIPT_NAME install            # Install/update dotfiles
  $SCRIPT_NAME profile server     # Change to server profile
  $SCRIPT_NAME verify             # Check symlink status
  DOTFILES_PROFILE=develop $SCRIPT_NAME install

For more information, visit: $DOCS_URL
EOF
}

# =============================================================================
# Main Function
# =============================================================================
# Initialize script environment
init_script() {
    readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Load existing configuration and set defaults
    load_config
    set_defaults
}

# Parse and validate command line arguments
parse_args() {
    local command="${1:-}"

    # Handle global options first
    case "$command" in
        -v|--verbose)
            export DOTFILES_VERBOSE="true"
            shift
            command="${1:-}"
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        --version)
            show_version
            exit 0
            ;;
    esac

    # Parse commands
    case "$command" in
        ""|install)
            if is_interactive && [[ -z "$command" ]]; then
                interactive_menu
            else
                with_menu_output install_dotfiles
            fi
            ;;
        uninstall)
            with_menu_output uninstall_dotfiles
            ;;
        link)
            with_menu_output create_symlinks
            ;;
        profile)
            handle_profile_command "${2:-}"
            ;;
        packages)
            with_menu_output install_packages
            ;;
        verify)
            with_menu_output verify_symlinks
            ;;
        version)
            show_version
            ;;
        help|-h|--help)
            show_usage
            ;;
        *)
            if [[ -n "$command" ]]; then
                log_error "Unknown command: $command"
                echo
                show_usage
                exit 1
            fi
            ;;
    esac
}

# Handle profile command with validation
handle_profile_command() {
    local new_profile="$1"

    if [[ -z "$new_profile" ]]; then
        log_error "Profile name required. Usage: $SCRIPT_NAME profile <minimal|server|develop>"
        return 1
    fi

    if ! validate_profile "$new_profile"; then
        return 1
    fi

    export DOTFILES_PROFILE="$new_profile"
    save_config
    log_success "Profile changed to: $new_profile"
    return 0
}

main() {
    init_script
    parse_args "$@"
}

# Run main function with error handling
if main "$@"; then
    exit 0
else
    exit 1
fi

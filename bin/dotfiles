#!/usr/bin/env bash

# =============================================================================
# Dotfiles Manager - Clean, Cross-Platform Installation Script
# =============================================================================
# Features: Interactive/Non-interactive, Profile-based, Cross-platform
# Supports: macOS (Darwin), Linux (Ubuntu, Fedora, Arch, etc.)
# Author: Veteran Programmer - Clean, Maintainable, Production-Ready Code
# =============================================================================

# Enable strict error handling
set -euo pipefail

# =============================================================================
# Configuration & Constants
# =============================================================================
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_NAME="dotfiles"
readonly DEFAULT_ROOT="$HOME/.dotfiles"
readonly DEFAULT_PROFILE="minimal"
readonly DEFAULT_VERBOSE="false"
readonly DEFAULT_BRANCH="main"

# URLs - Easy to update
readonly REPO_URL="https://github.com/ved0el/dotfiles.git"
readonly INSTALL_COMMAND_URL="https://tinyurl.com/get-dotfiles"
readonly DOCS_URL="https://github.com/ved0el/dotfiles"

# Configuration file location
readonly CONFIG_FILE="$HOME/.zshenv"

# =============================================================================
# Cross-Platform Detection & Utilities
# =============================================================================
get_os_type() { uname -s; }

get_linux_distro() {
    [[ -f /etc/os-release ]] && source /etc/os-release 2>/dev/null && echo "${ID:-unknown}" || echo "unknown"
}

# Cross-platform stat command
stat_modification_time() {
    local file="$1"
    if command -v stat &>/dev/null; then
        # Try GNU stat first (Linux), fallback to macOS/BSD
        stat --version 2>/dev/null | grep -q "GNU" && stat -c %Y "$file" 2>/dev/null || stat -f %m "$file" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

# Cross-platform sed in-place editing
sed_inplace() {
    local file="$1"; shift
    [[ "$(get_os_type)" == "Darwin" ]] && sed -i '' "$@" "$file" || sed -i "$@" "$file"
}

# Extract value from config line (format: export VAR="value")
extract_config_value() {
    local var_name="$1"
    local config_file="$2"

    # Simple extraction using bash parameter expansion
    local line
    line=$(grep "^export ${var_name}=" "$config_file" 2>/dev/null || echo "")
    [[ -z "$line" ]] && return 1

    # Extract value between quotes
    local value="${line#*\"}"  # Remove everything before first quote
    value="${value%\"*}"      # Remove everything after last quote

    [[ -n "$value" ]] && echo "$value"
}

# =============================================================================
# Color & UI Constants
# =============================================================================
# ANSI color codes - compatible with most terminals
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;90m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly NC='\033[0m'  # No Color (reset)

# UI symbols - fallback to ASCII if Unicode not supported
readonly CHECK="âœ“"
readonly CROSS="âœ—"
readonly ARROW="â†’"
readonly BULLET="â€¢"

# =============================================================================
# Logging Functions
# =============================================================================
log_info() { echo -e "${CYAN}${BULLET}${NC} ${WHITE}$1${NC}"; }
log_success() { echo -e "${GREEN}${CHECK}${NC} ${BOLD}$1${NC}"; }
log_warning() { echo -e "${YELLOW}âš ${NC}  ${YELLOW}$1${NC}"; }
log_error() { echo -e "${RED}${CROSS}${NC} ${RED}${BOLD}$1${NC}"; }
log_step() { echo -e "${PURPLE}${ARROW}${NC} ${BOLD}$1${NC}"; }
log_dim() { echo -e "${GRAY}${DIM}  $1${NC}"; }
log_verbose() { [[ "${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}" == "true" ]] && echo -e "${GRAY}${DIM}[VERBOSE] $1${NC}"; }

# =============================================================================
# Validation Functions
# =============================================================================
# Validate profile value
validate_profile() {
    local profile="$1"
    local valid_profiles=("minimal" "server" "develop")

    for valid_profile in "${valid_profiles[@]}"; do
        [[ "$profile" == "$valid_profile" ]] && return 0
    done

    die "Invalid profile '$profile'. Valid profiles: ${valid_profiles[*]}"
}

# Validate verbose value
validate_verbose() {
    local verbose="$1"
    [[ "$verbose" =~ ^(true|false)$ ]] && return 0

    log_warning "Invalid verbose value '$verbose', defaulting to '$DEFAULT_VERBOSE'"
    return 1
}

is_interactive() { [[ -t 0 && -t 1 ]]; }

die() { log_error "$1"; exit 1; }

# =============================================================================
# Banner & UI Functions
# =============================================================================
show_banner() {
    echo -e "${BOLD}${BLUE}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${BOLD}${BLUE}â”‚${NC}                    ${BOLD}${WHITE}ðŸš€ Dotfiles Manager${NC}                         ${BOLD}${BLUE}â”‚${NC}"
    echo -e "${BOLD}${BLUE}â”‚${NC}              ${GRAY}Clean, Cross-Platform Setup${NC}                       ${BOLD}${BLUE}â”‚${NC}"
    echo -e "${BOLD}${BLUE}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
    echo
}

show_section() {
    echo; echo -e "${BOLD}${PURPLE}â—† $1${NC}"
    echo -e "${GRAY}${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

show_subsection() { echo -e "${CYAN}${BULLET} ${BOLD}$1${NC}"; }

# =============================================================================
# Configuration Management
# =============================================================================
load_config() {
    [[ ! -f "$CONFIG_FILE" ]] && {
        export DOTFILES_CONFIG_LOADED_FROM_ZSHENV=false
        log_verbose "No configuration file found at $CONFIG_FILE"
        return 0
    }

    log_verbose "Loading configuration from $CONFIG_FILE"

    # Load configuration values with fallbacks
    local value

    # Use || true to prevent set -e from exiting on grep/sed failures
    if value=$(extract_config_value "DOTFILES_ROOT" "$CONFIG_FILE" 2>/dev/null || true); then
        [[ -n "$value" ]] && export DOTFILES_ROOT="$value"
        log_verbose "Loaded DOTFILES_ROOT: ${value:-default}"
    fi

    if value=$(extract_config_value "DOTFILES_PROFILE" "$CONFIG_FILE" 2>/dev/null || true); then
        [[ -n "$value" ]] && export DOTFILES_PROFILE="$value"
        log_verbose "Loaded DOTFILES_PROFILE: ${value:-default}"
    fi

    if value=$(extract_config_value "DOTFILES_VERBOSE" "$CONFIG_FILE" 2>/dev/null || true); then
        [[ -n "$value" ]] && export DOTFILES_VERBOSE="$value"
        log_verbose "Loaded DOTFILES_VERBOSE: ${value:-default}"
    fi

    export DOTFILES_CONFIG_LOADED_FROM_ZSHENV=true
    log_verbose "Configuration loaded successfully"
}

save_config() {
    # Ensure config directory exists
    local config_dir
    config_dir=$(dirname "$CONFIG_FILE")
    [[ ! -d "$config_dir" ]] && mkdir -p "$config_dir"

    # Create backup if config file exists
    [[ -f "$CONFIG_FILE" ]] && cp "$CONFIG_FILE" "${CONFIG_FILE}.backup" 2>/dev/null

    # Remove existing dotfiles exports and comments
    if [[ -f "$CONFIG_FILE" ]]; then
        sed_inplace "$CONFIG_FILE" '/^export DOTFILES_/d'
        sed_inplace "$CONFIG_FILE" '/^# Dotfiles Configuration/d'
    fi

    # Add new configuration block with timestamp
    cat >> "$CONFIG_FILE" << EOF
# Dotfiles Configuration
export DOTFILES_ROOT="${DOTFILES_ROOT:-$DEFAULT_ROOT}"
export DOTFILES_PROFILE="${DOTFILES_PROFILE:-$DEFAULT_PROFILE}"
export DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"
EOF

    log_verbose "Configuration saved to $CONFIG_FILE"
}

# =============================================================================
# Environment Setup
# =============================================================================
setup_environment() {
    show_section "Configuration Setup"

    # Load existing configuration
    load_config

    # Set defaults
    export DOTFILES_ROOT="${DOTFILES_ROOT:-$DEFAULT_ROOT}"
    export DOTFILES_PROFILE="${DOTFILES_PROFILE:-$DEFAULT_PROFILE}"
    export DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"
    export DOTFILES_BRANCH="${DOTFILES_BRANCH:-$DEFAULT_BRANCH}"

    # Auto-detect repository
    if [[ -z "${DOTFILES_REPO:-}" ]]; then
        if [[ -d "$SCRIPT_DIR/.git" ]]; then
            DOTFILES_REPO=$(cd "$SCRIPT_DIR" && git remote get-url origin 2>/dev/null || echo "")
            log_verbose "Auto-detected repository from local git"
        else
            DOTFILES_REPO="$REPO_URL"
            log_verbose "Using default repository"
        fi
    fi
    export DOTFILES_REPO

    # Validate settings
    validate_profile "$DOTFILES_PROFILE"
    validate_verbose "$DOTFILES_VERBOSE"

}

# =============================================================================
# Repository Management
# =============================================================================
setup_repository() {
    show_section "Repository Management"

    if [[ -d "$DOTFILES_ROOT/.git" ]]; then
        log_step "Updating existing repository"
        cd "$DOTFILES_ROOT"
        log_dim "Fetching latest changes..."
        git fetch origin >/dev/null 2>&1
        log_dim "Switching to branch '$DOTFILES_BRANCH'..."
        git checkout "$DOTFILES_BRANCH" >/dev/null 2>&1
        log_dim "Pulling latest changes..."
        git pull origin "$DOTFILES_BRANCH" >/dev/null 2>&1
    else
        log_step "Cloning repository"
        [[ -n "$DOTFILES_REPO" ]] || die "Repository URL not specified"
        log_dim "Downloading from $DOTFILES_REPO..."
        git clone -b "$DOTFILES_BRANCH" "$DOTFILES_REPO" "$DOTFILES_ROOT" >/dev/null 2>&1
    fi

    cd "$DOTFILES_ROOT"
    log_success "Repository ready at $DOTFILES_ROOT"
}

# =============================================================================
# Symlink Management
# =============================================================================
readonly EXCLUDE_PATTERNS=(
    "README.md" ".gitignore" "install" "bin" "config" "zshrc.d"
    ".vscode" ".git" "*.zwc" "*.zwc.old"
)

should_exclude() {
    local item="$1"
    for pattern in "${EXCLUDE_PATTERNS[@]}"; do
        # Use glob matching for patterns with wildcards, exact match otherwise
        if [[ "$pattern" == *"*"* ]]; then
            [[ "$item" == $pattern ]] && return 0
        else
            [[ "$item" == "$pattern" ]] && return 0
        fi
    done
    return 1
}

# Create a symlink with proper error handling
create_single_symlink() {
    local source_path="$1"
    local target_path="$2"
    local display_name="$3"

    # Remove existing symlink or file
    if [[ -L "$target_path" || -e "$target_path" ]]; then
        rm -rf "$target_path" || {
            log_error "Failed to remove existing $target_path"
            return 1
        }
    fi

    # Create symlink
    if ln -sf "$source_path" "$target_path"; then
        log_dim "${GREEN}${CHECK}${NC} $display_name ${ARROW} $target_path"
        return 0
    else
        log_error "Failed to create symlink: $source_path -> $target_path"
        return 1
    fi
}

# Link files from source directory to target directory
link_directory_files() {
    local source_dir="$1"
    local target_prefix="$2"
    local subsection_title="$3"

    [[ ! -d "$source_dir" ]] && return 0

    show_subsection "$subsection_title"

    local linked_count=0
    local failed_count=0

    for item in "$source_dir"/*; do
        [[ ! -e "$item" ]] && continue  # Skip if item doesn't exist

        local name=$(basename "$item")
        local target="$target_prefix$name"

        # Ensure target directory exists
        local target_dir
        target_dir=$(dirname "$target")
        [[ ! -d "$target_dir" ]] && mkdir -p "$target_dir"

        if ! should_exclude "$name" && [[ -f "$item" || -d "$item" ]]; then
            if create_single_symlink "$item" "$target" "$name"; then
                ((linked_count++))
            else
                ((failed_count++))
            fi
        fi
    done

    log_verbose "Linked $linked_count files from $source_dir"
    [[ $failed_count -gt 0 ]] && log_warning "Failed to link $failed_count files"
}

create_symlinks() {
    [[ "${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}" != "true" ]] && return 0

    show_section "Creating symlinks..."

    # Link dotfiles (files in root directory)
    link_directory_files "$DOTFILES_ROOT" "$HOME/." "Linking dotfiles..."

    # Link config files
    mkdir -p "$HOME/.config"
    link_directory_files "$DOTFILES_ROOT/config" "$HOME/.config/" "Linking config files..."
}

# Check symlinks in a directory
check_directory_symlinks() {
    local source_dir="$1"
    local target_prefix="$2"
    local subsection_title="$3"
    local total_links_ref="$4"
    local broken_links_ref="$5"

    [[ ! -d "$source_dir" ]] && return 0

    show_subsection "$subsection_title"

    local item_count=0

    while IFS= read -r item; do
        [[ -z "$item" ]] && continue

        local name=$(basename "$item")
        local target="$target_prefix$name"

        if ! should_exclude "$name" && [[ -f "$item" || -d "$item" ]]; then
            ((item_count++))
            if [[ -L "$target" ]] && [[ -e "$target" ]]; then
                log_dim "${GREEN}${CHECK}${NC} $name ${ARROW} $target"
                eval "$total_links_ref=\$(($total_links_ref + 1))"
            else
                log_error "${RED}${CROSS}${NC} Broken or missing: $target"
                eval "$broken_links_ref=\$(($broken_links_ref + 1))"
            fi
        fi
    done < <(ls -1 "$source_dir" 2>/dev/null || echo "")

    log_verbose "Checked $item_count items in $source_dir"
}

verify_symlinks() {
    show_section "Verifying symlinks..."

    [[ -n "$DOTFILES_ROOT" ]] || { log_error "DOTFILES_ROOT is not set"; return 1; }
    [[ -d "$DOTFILES_ROOT" ]] || { log_error "Dotfiles directory not found: $DOTFILES_ROOT"; return 1; }

    local total_links=0
    local broken_links=0

    # Check dotfiles symlinks
    check_directory_symlinks "$DOTFILES_ROOT" "$HOME/." "Checking dotfiles symlinks..." total_links broken_links

    # Check config files symlinks
    check_directory_symlinks "$DOTFILES_ROOT/config" "$HOME/.config/" "Checking config files symlinks..." total_links broken_links

    # Summary
    echo
    if [[ $broken_links -eq 0 ]]; then
        log_success "All $total_links symlinks are working"
        return 0
    else
        log_warning "Found $broken_links broken symlinks out of $total_links total"
        return 1
    fi
}

# =============================================================================
# Package Installation
# =============================================================================
install_packages() {
    show_section "Package Installation"

    # Check if zsh is available
    command -v zsh &>/dev/null || {
        log_warning "zsh not found, skipping package installation"
        return 0
    }

    log_info "Installing packages for profile: $DOTFILES_PROFILE"

    # Determine which packages to install based on profile
    local pkg_patterns=()
    case "$DOTFILES_PROFILE" in
        minimal) pkg_patterns=('*_m_*.zsh') ;;
        server)  pkg_patterns=('*_m_*.zsh' '*_s_*.zsh') ;;
        develop) pkg_patterns=('*_m_*.zsh' '*_s_*.zsh' '*_d_*.zsh') ;;
    esac

    # Source each matching package file to trigger installation
    (   # Subshell to contain shopt changes
        shopt -s nullglob  # Allow empty globs
        for pattern in "${pkg_patterns[@]}"; do
            for pkg_file in "$DOTFILES_ROOT/zshrc.d/pkg/$pattern"; do
                if [[ -f "$pkg_file" ]]; then
                    log_dim "Loading package: $(basename "$pkg_file")"
                    source "$pkg_file"
                fi
            done
        done
    )

    log_success "Package installation completed"
}

# =============================================================================
# Profile Management
# =============================================================================
configure_profile() {
    log_info "Configuring profile: $DOTFILES_PROFILE"
    save_config
    log_success "Profile configured successfully"
}

# =============================================================================
# Main Installation Flow
# =============================================================================
install_dotfiles() {
    show_banner
    log_step "Starting dotfiles installation"
    setup_environment
    setup_repository
    install_packages
    create_symlinks
    verify_symlinks
    configure_profile

    # Success message
    echo
    echo -e "${BOLD}${GREEN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${BOLD}${GREEN}â”‚${NC}${BOLD}${WHITE}                    ðŸŽ‰ Installation Complete!                   ${NC}${BOLD}${GREEN}â”‚${NC}"
    echo -e "${BOLD}${GREEN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
    echo

    log_success "Profile '$DOTFILES_PROFILE' is now active"

    # Show what's included
    echo
    echo -e "${BOLD}${WHITE}What's Included:${NC}"
    case "$DOTFILES_PROFILE" in
        minimal)
            echo -e "  ${GREEN}${CHECK}${NC} Shell essentials (zsh, sheldon, tmux)"
            ;;
        server)
            echo -e "  ${GREEN}${CHECK}${NC} Shell + utilities (bat, fzf, eza, fd, ripgrep, tealdeer, zoxide)"
            ;;
        develop)
            echo -e "  ${GREEN}${CHECK}${NC} Full development environment"
            echo -e "  ${GREEN}${CHECK}${NC} All server tools + dev tools (nvm, pyenv, goenv, curlie)"
            ;;
    esac

    # Start new shell
    if command -v zsh &>/dev/null; then
        log_info "Starting new zsh shell..."
        exec zsh -l </dev/null
    else
        log_warning "zsh not found, please restart your terminal manually"
    fi
}

# =============================================================================
# Uninstallation
# =============================================================================
uninstall_dotfiles() {
    log_warning "This will remove all dotfiles symlinks and configuration"

    if is_interactive; then
        echo -n "Are you sure? [y/N]: "
        read -r response
        [[ ! "$response" =~ ^[Yy]$ ]] && { log_info "Uninstallation cancelled"; return 0; }
    fi

    local unlink_count=0

    # Remove root symlinks
    if [[ -d "$DOTFILES_ROOT" ]]; then
        for item in "$DOTFILES_ROOT"/*; do
            [[ -f "$item" ]] || continue
            local name="$(basename "$item")"
            local target="$HOME/.$name"
            if [[ -L "$target" ]] && [[ "$(readlink "$target")" == *"/.dotfiles/"* ]]; then
                rm "$target"
                ((unlink_count++))
            fi
        done
    fi

    # Remove config symlinks
    if [[ -d "$HOME/.config" ]]; then
        for item in "$HOME/.config"/*; do
            if [[ -L "$item" ]] && [[ "$(readlink "$item")" == *"/.dotfiles/"* ]]; then
                rm "$item"
                ((unlink_count++))
            fi
        done
    fi

    # Remove from .zshenv
    local zshenv="$HOME/.zshenv"
    if [[ -f "$zshenv" ]]; then
        sed_inplace "$zshenv" '/^export DOTFILES_/d'
        sed_inplace "$zshenv" '/^# Dotfiles Configuration/d'
    fi

    # Remove dotfiles directory
    [[ -d "$DOTFILES_ROOT" ]] && rm -rf "$DOTFILES_ROOT"

    log_success "Removed $unlink_count symlinks and dotfiles directory"
}

# =============================================================================
# Interactive Menu
# =============================================================================
show_menu() {
    clear
    show_banner

    # Ensure variables are set with defaults
    DOTFILES_ROOT="${DOTFILES_ROOT:-$DEFAULT_ROOT}"
    DOTFILES_PROFILE="${DOTFILES_PROFILE:-$DEFAULT_PROFILE}"
    DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"

    echo -e "${BOLD}${WHITE}Current Configuration:${NC}"
    echo -e "  ${GRAY}OS:${NC}                  ${PURPLE}$(get_os_type)${NC}"
    echo -e "  ${GRAY}Path:${NC}                ${CYAN}${DOTFILES_ROOT}${NC}"
    echo -e "  ${GRAY}Profile:${NC}             ${YELLOW}${DOTFILES_PROFILE}${NC}"
    echo -e "  ${GRAY}Verbose:${NC}             ${GREEN}${DOTFILES_VERBOSE}${NC}"

    echo
    echo -e "${BOLD}${WHITE}Available Actions:${NC}"
    echo -e "  ${CYAN}1)${NC} Install/Update dotfiles"
    echo -e "  ${CYAN}2)${NC} Change profile (minimal/server/develop)"
    echo -e "  ${CYAN}3)${NC} Create/refresh symlinks only"
    echo -e "  ${CYAN}4)${NC} Install required packages"
    echo -e "  ${CYAN}5)${NC} Verify symlinks"
    echo -e "  ${CYAN}6)${NC} Uninstall everything"
    echo -e "  ${CYAN}7)${NC} Toggle verbose mode"
    echo -e "  ${CYAN}8)${NC} Show help"
    echo -e "  ${CYAN}q)${NC} Quit"

    echo
    echo -n "Choose an option [1-8,q]: "
}

interactive_menu() {
    # Load existing configuration for interactive session
    load_config

    while true; do
        show_menu
        read -r choice

        case "$choice" in
            1)
                install_dotfiles
                ;;
            2)
                echo -n "Enter new profile (minimal/server/develop): "
                read -r new_profile
                case "$new_profile" in
                    minimal|server|develop)
                        export DOTFILES_PROFILE="$new_profile"
                        log_success "Profile changed to: $new_profile"
                        ;;
                    *) log_error "Invalid profile. Use: minimal, server, or develop" ;;
                esac
                sleep 2
                ;;
            3)
                create_symlinks
                verify_symlinks
                echo -e "\n${GRAY}${DIM}Press Enter to continue...${NC}"
                read -r
                ;;
            4)
                install_packages
                echo -e "\n${GRAY}${DIM}Press Enter to continue...${NC}"
                read -r
                ;;
            5)
                verify_symlinks
                echo -e "\n${GRAY}${DIM}Press Enter to continue...${NC}"
                read -r
                ;;
            6)
                uninstall_dotfiles
                [[ $? -eq 0 ]] && exit 0
                echo -e "\n${GRAY}${DIM}Press Enter to continue...${NC}"
                read -r
                ;;
            7)
                # Toggle verbose mode
                if [[ "${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}" == "true" ]]; then
                    export DOTFILES_VERBOSE="false"
                    log_success "Verbose mode disabled"
                else
                    export DOTFILES_VERBOSE="true"
                    log_success "Verbose mode enabled"
                fi
                save_config
                sleep 2
                ;;
            8)
                echo
                echo -e "${BOLD}${PURPLE}Help - Dotfiles Manager${NC}"
                echo
                echo -e "${BOLD}${WHITE}Installation:${NC}"
                echo -e "  ${CYAN}${BULLET}${NC} Interactive: bash <(curl -fsSL $INSTALL_COMMAND_URL)"
                echo -e "  ${CYAN}${BULLET}${NC} One-liner:   curl -fsSL $INSTALL_COMMAND_URL | bash"
                echo
                echo -e "${BOLD}${WHITE}Profiles:${NC}"
                echo -e "  ${YELLOW}minimal${NC}  - Shell essentials (sheldon, tmux)"
                echo -e "  ${YELLOW}server${NC}   - Shell + utilities (bat, fzf, eza, etc.)"
                echo -e "  ${YELLOW}develop${NC}  - Full development environment"
                echo
                echo -e "${BOLD}${WHITE}Environment Variables:${NC}"
                echo -e "  ${CYAN}DOTFILES_ROOT${NC}     - Installation directory"
                echo -e "  ${CYAN}DOTFILES_PROFILE${NC}  - Profile selection"
                echo -e "  ${CYAN}DOTFILES_VERBOSE${NC}  - Enable verbose logging"
                echo
                echo -e "${GRAY}${DIM}Press Enter to continue...${NC}"
                read -r
                ;;
            q)
                save_config
                log_success "Goodbye!"
                exit 0
                ;;
            *) log_error "Invalid choice"; sleep 1 ;;
        esac
    done
}

# =============================================================================
# Command Line Interface
# =============================================================================
show_version() {
    echo "$SCRIPT_NAME v$SCRIPT_VERSION"
    echo "Cross-platform dotfiles manager"
    echo "https://github.com/ved0el/dotfiles"
}

show_usage() {
    show_version
    echo
    cat << EOF
USAGE:
  $SCRIPT_NAME [COMMAND] [OPTIONS]

COMMANDS:
  install     Install or update dotfiles (default)
  uninstall   Remove all dotfiles and configuration
  link        Create or refresh symlinks only
  profile     Change profile (minimal/server/develop)
  packages    Install required packages for current profile
  verify      Verify all symlinks are working
  version     Show version information
  help        Show this help message

OPTIONS:
  -v, --verbose    Enable verbose output
  -h, --help       Show this help message

EXAMPLES:
  $SCRIPT_NAME                    # Interactive installation
  $SCRIPT_NAME install            # Install/update dotfiles
  $SCRIPT_NAME profile server     # Change to server profile
  $SCRIPT_NAME verify             # Check symlink status
  DOTFILES_PROFILE=develop $SCRIPT_NAME install

For more information, visit: $DOCS_URL
EOF
}

# =============================================================================
# Main Function
# =============================================================================
# Initialize script environment
init_script() {
    readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Load existing configuration
    load_config

    # Set default values if not loaded
    export DOTFILES_ROOT="${DOTFILES_ROOT:-$DEFAULT_ROOT}"
    export DOTFILES_PROFILE="${DOTFILES_PROFILE:-$DEFAULT_PROFILE}"
    export DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-$DEFAULT_VERBOSE}"
}

# Parse and validate command line arguments
parse_args() {
    local command="${1:-}"

    # Handle global options first
    case "$command" in
        -v|--verbose)
            export DOTFILES_VERBOSE="true"
            shift
            command="${1:-}"
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        --version)
            show_version
            exit 0
            ;;
    esac

    # Parse commands
    case "$command" in
        ""|install)
            if is_interactive && [[ -z "$command" ]]; then
                interactive_menu
            else
                install_dotfiles
            fi
            ;;
        uninstall)
            uninstall_dotfiles
            ;;
        link)
            create_symlinks
            ;;
        profile)
            handle_profile_command "$2"
            ;;
        packages)
            install_packages
            ;;
        verify)
            verify_symlinks
            ;;
        version)
            show_version
            ;;
        help|-h|--help)
            show_usage
            ;;
        *)
            if [[ -n "$command" ]]; then
                log_error "Unknown command: $command"
                echo
                show_usage
                exit 1
            fi
            ;;
    esac
}

# Handle profile command with validation
handle_profile_command() {
    local new_profile="$1"

    if [[ -z "$new_profile" ]]; then
        die "Profile name required. Usage: $SCRIPT_NAME profile <minimal|server|develop>"
    fi

    if ! validate_profile "$new_profile" 2>/dev/null; then
        die "Invalid profile '$new_profile'. Valid profiles: minimal, server, develop"
    fi

    export DOTFILES_PROFILE="$new_profile"
    save_config
    log_success "Profile changed to: $new_profile"
}

main() {
    init_script
    parse_args "$@"
}

# Run main function with error handling
if main "$@"; then
    exit 0
else
    exit 1
fi
